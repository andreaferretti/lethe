{"name":"Lethe","tagline":"Oblivious RAM for Scala","body":"#Lethe\r\n\r\n![logo](https://raw.githubusercontent.com/unicredit/lethe/master/lethe.png)\r\n\r\nThis is a library designed to provide an [Oblivious RAM](http://outsourcedbits.org/2013/12/20/how-to-search-on-encrypted-data-part-4-oblivious-rams/)\r\nand some higher-level tools on top of it.\r\n\r\nMore specifically, Lethe is an implementation of [Path ORAM](https://eprint.iacr.org/2013/280.pdf).\r\n\r\nTable of contents\r\n-----------------\r\n\r\n<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->\r\n\r\n- [Lethe](#lethe)\r\n\t- [So, what is an oblivious RAM?](#so-what-is-an-oblivious-ram)\r\n\t- [Goals](#goals)\r\n\t- [Status](#status)\r\n\t- [Glossary](#glossary)\r\n\r\n<!-- /TOC -->\r\n\r\n##So, what is an oblivious RAM?\r\n\r\nIs is a model that helps when designing applications that delegate an untrusted\r\nserver with access to their data (think cloud computing). Of course, in such a\r\nsituation, one should encrypt the data on the client side.\r\n\r\n[Turns out](https://www.internetsociety.org/sites/default/files/06_1.pdf) this\r\nis [not enough](https://eprint.iacr.org/2013/163.pdf). Observation of the access\r\npatterns to the data can allow an attacker to gain significant information. As\r\nshown in the papers above, actual attacks can be mounted and this is not only a\r\ntheoretical concern.\r\n\r\nOblivious RAM models a random access data structure giving guarantees that the\r\nattacker will not learn anything other than the frequency of access and the\r\noverall size of data. Various techniques exist, all based on the idea of\r\ncontinuously shuffling memory as it is being accessed.\r\n\r\nLethe is an implementation of [Path ORAM](https://eprint.iacr.org/2013/280.pdf).\r\n\r\n##Goals\r\n\r\nThe end goal is to provide a complete implementation of Path ORAM in Scala, that\r\nworks both on the JVM and in [Scala.js](http://www.scala-js.org/).\r\n\r\nOn top of that, various higher-level features can be constructed:\r\n\r\n* data indices to allow serching encrypted data\r\n* support for SQL-like queries\r\n* [oblivious data structures](https://eprint.iacr.org/2014/185.pdf)\r\n\r\nEventually, the long term aim would be to provide a deployable server together\r\nwith a client library of data structures that can be mapped on the server and\r\nsome form of SQL support.\r\n\r\n##Status\r\n\r\nCurrently Lethe contains a basic implementation of Path ORAM that uses\r\n[ZeroMQ](http://zeromq.org/) to communicate synchronously with a server.\r\nThe server is very minimal, and can either work in memory, or use\r\n[LevelDB](https://github.com/wlu-mstr/leveldb-java) as a storage backend to\r\npersist data across sessions.\r\n\r\nA recursive form of the Path ORAM algorithm is used to minimize the amount of\r\ndata that the client has to keep.\r\n\r\nOn top of that, a very basic form of indexing is developed, allowing search\r\non both structured data and free text.\r\n\r\nA lot remains to be done, and here is a tentative plan:\r\n\r\n* Clients have to mantain some form of key to get access to the data. This\r\n  includes both a private key in the traditional sense, and additional\r\n  information that allows to reconstruct to structure of data on the server.\r\n  Everything is designed so that such information is serializable, but a\r\n  mechanism to save the key to a file and restore a previous session is not\r\n  implemented yet.\r\n* Making it work in Scala.js. Most of the work is done: we have chosen\r\n  libraries that cross-compile, and the communication with the server itself\r\n  is handled by a very simple interface, allowing other transports than\r\n  ZeroMQ. But in the browser we cannot use a synchronous model of communication,\r\n  and this impacts the algorithms. Once everything is stable, we can port it\r\n  to an asynchronous model using [async/await](https://github.com/scala/async),\r\n  and then implement the relevant transport interface over AJAX.\r\n* The indexing technique is currently very rough, and only serves as a proof\r\n  of concept. We should develop more sophisticated, fast and flexible indices.\r\n* The server is currently not very robust and not designed to handle multiple\r\n  clients. It is ok just for the proof of concept, but is not in any sense an\r\n  actual usable server.\r\n* We could make use of something like [Catalyst](https://github.com/apache/spark/tree/master/sql/catalyst)\r\n  to parse SQL queries and translate them into a query plan that makes use of\r\n  random access as provided by the ORAM and indices. This would allow to\r\n  support a basic form of SQL in an oblivious manner.\r\n* The [oblivious data structures](https://eprint.iacr.org/2014/185.pdf) are not\r\n  implemented yet.\r\n\r\nThe package `unicredit.lethe.async` is currently lagging behind its sync\r\ncounterpart and will need to be adapted accordingly.\r\n\r\n\r\n##Glossary\r\n\r\nA `Remote` is an interface to read and write blocks of data, possibly to a\r\nserver. A trivial example is `MemoryRemote`, that just keeps the blocks in\r\nmemory without sending them at all. Alternatively, `ZMQRemote` talks to an\r\nactual remote ZeroMQ server.\r\n\r\nA `Serializer[A]` is used to convert between and `Array[Byte]` and back;\r\nby default we use BooPickle to handle this.\r\n\r\nA `Crypter` handles encryptions and decryption, working at the byte array\r\nlevel. An example is the `AESCrypter`.\r\n\r\nA `Client[A]` has access to all of them, and used this to talk to the server,\r\nsending and receiving encrypted instances of `A`. In particular,\r\n`StandardClient[A]` just puts together the three.\r\n\r\nAn `ORAM` has access to a `Client` that communicates to a server\r\nand makes sure that one can read or write instances of `Doc`, indexed by `Id`.\r\nThe `TrivialORAM` does this by always reading and writing back all\r\ndocuments for all operations.\r\n\r\n`PathORAM` does this by implementing the actual Path ORAM construction.\r\nThe index that maps each `Id` to the relative `Path` is kept abstract in\r\norder to handle recursion. In `LocalPathORAM`, we specialize the index\r\nto be a local `Map[Id, Path]`, while `RecursivePathORAM` stores the\r\nindex as an ORAM itself.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}